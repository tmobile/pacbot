/*
 *Copyright 2018 T Mobile, Inc. or its affiliates. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); You may not use
 * this file except in compliance with the License. A copy of the License is located at
 * 
 * http://www.apache.org/licenses/LICENSE-2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed on
 * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, express or
 * implied. See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { Component, OnInit, ElementRef, ViewChild, Input, OnDestroy } from '@angular/core';
import { Subscription } from 'rxjs/Subscription';
import { AssetGroupObservableService } from '../../../core/services/asset-group-observable.service';
import { AutorefreshService } from '../../services/autorefresh.service';
import { environment } from './../../../../environments/environment';
import { ActivatedRoute, Router } from '@angular/router';
import { LoggerService } from '../../../shared/services/logger.service';
import { ErrorHandlingService } from '../../../shared/services/error-handling.service';
import { UtilsService } from '../../../shared/services/utils.service';
import { WorkflowService } from '../../../core/services/workflow.service';
import { CommonResponseService } from '../../../shared/services/common-response.service';

@Component({
  selector: 'app-vulnerability-overall',
  templateUrl: './vulnerability-overall.component.html',
  styleUrls: ['./vulnerability-overall.component.css'],
  providers: [LoggerService , ErrorHandlingService, CommonResponseService, AutorefreshService]
})

export class VulnerabilityOverallComponent implements OnInit, OnDestroy {
  @ViewChild('widget') widgetContainer: ElementRef;

  subscriptionToAssetGroup: Subscription;
  selectedAssetGroup: string;
  public apiData: any;
  public applicationValue: any;
  public errorMessage: any;
  public dataComing = true;
  public showLoader = true;
  public low = false;
  public medium = false;
  public full = false;
  durationParams: any;
  autoRefresh: boolean;
  public graphData: any;
  public widgetWidth: number;
  public widgetHeight: number;
  public colorTransData: any;
  public seekdata = false;
  public graphLegend: any = [];
  public MainTextcolor: any = '';
  public innerRadious =  60;
  public outerRadious =  50;
  public strokeColor = 'transparent';
  public totalGrpahCount = 0;
  routeTo = 'vulnerabilities';
  private urlToRedirect;

  private autorefreshInterval;
  @Input() pageLevel: number;

  constructor(
    private commonResponseService: CommonResponseService,
    private assetGroupObservableService: AssetGroupObservableService,
    private autorefreshService: AutorefreshService,
    private logger: LoggerService, private errorHandling: ErrorHandlingService,
    private router: Router, private activatedRoute: ActivatedRoute,
    private utils: UtilsService,
    private workflowService: WorkflowService
  ) {

    this.subscriptionToAssetGroup = this.assetGroupObservableService.getAssetGroup().subscribe(
      assetGroupName => {
          this.selectedAssetGroup = assetGroupName;
          this.updateComponent();
    });
    this.durationParams = this.autorefreshService.getDuration();
    this.durationParams = parseInt(this.durationParams, 10);
    this.autoRefresh = this.autorefreshService.autoRefresh;
   }

   ngOnInit() {
    this.urlToRedirect = this.router.routerState.snapshot.url;
    this.widgetWidth = parseInt(window.getComputedStyle(this.widgetContainer.nativeElement, null).getPropertyValue('width'), 10);
    this.widgetHeight = parseInt(window.getComputedStyle(this.widgetContainer.nativeElement, null).getPropertyValue('height'), 10);

    const afterLoad = this;
    if (this.autoRefresh !== undefined) {
      if ((this.autoRefresh === true ) || (this.autoRefresh.toString() === 'true')) {

        this.autorefreshInterval = setInterval(function() {
          afterLoad.getProgressData();
        }, this.durationParams);
      }
    }
  }

  /* Function to repaint component */
  updateComponent() {

    /* All functions variables which are required to be set for component to be reloaded should go here */
    this.seekdata = false;
    this.dataComing = false;
    this.showLoader = true;
    this.graphData = 0;
    this.getData();
  }

  /* Function to get Data */
  getData() {

      /* All functions to get data should go here */
      this.getProgressData();
  }
  getProgressData() {
    const queryParams = {
      'ag': this.selectedAssetGroup
  };
  const vulnerabilitySummaryUrl = environment.vulnerabilitySummary.url;
  const vulnerabilitySummaryMethod = environment.vulnerabilitySummary.method;

  this.commonResponseService.getData( vulnerabilitySummaryUrl, vulnerabilitySummaryMethod, {}, queryParams).subscribe(
    response => {
      this.apiData = response;
      try {

        if (this.apiData === undefined || this.apiData === '' || this.apiData == null) {
          this.errorMessage = 'noDataAvailable';
          this.getErrorValues();
        } else {
          this.showLoader = false;
          this.seekdata = false;
          this.dataComing = true;
          this.applicationValue = this.apiData.distribution;
          this.processGraphData(this.applicationValue);
          this.getColour(this.applicationValue);
        }
      } catch (error) {
          this.errorMessage = 'noDataAvailable';
          this.getErrorValues();
      }
   },
   error => {
     this.errorMessage = 'apiResponseError';
     this.getErrorValues();
   });

  }

   // assign error values...

   getErrorValues(message?: any ): void {
      this.showLoader = false;
      this.dataComing = false;
      this.seekdata = true;
      if (message) {
        this.errorMessage = message;
      }
    }
  /**
   * this function return colour based on value
   */
  getColour(data) {
    if ((data.compliantpercent >= 0) && (data.compliantpercent < 50)) {
      this.low = true;
      this.medium = false;
      this.full = false;
    } else if ((data.compliantpercent >= 50) && (data.compliantpercent < 100)) {
      this.medium = true;
      this.low = false;
      this.full = false;
    } else {
      this.full = true;
      this.low = false;
      this.medium = false;
    }
  }


  /**
   * extract data from response to plot the graph
   */


  processGraphData(data): void {

      /**
       * doughnut chart expects the following inputs
       */


      //  this foreach function checks for total count of graph
      // if totalcount is zero , it doesn't plot the graph


       this.totalGrpahCount = 0;
       data.severityinfo.forEach(element => {
         this.totalGrpahCount = this.totalGrpahCount + element.count;
       });

       if (this.totalGrpahCount  < 1 ) {
          this.graphData = 0;
       } else {
        this.colorTransData = ['#ffb00d', '#f75c03', '#e60127'];
        this.graphLegend = ['S3', 'S4', 'S5'];
        this.MainTextcolor = '#000';
        this.strokeColor = '#EFF3F6';
        this.graphData = data.severityinfo;
        const graphDataArray = [];
        const legendTextcolor = '#555555';
        this.innerRadious = 64;
        this.outerRadious = 50;

        this.graphData.forEach(element => {
          graphDataArray.push(element.count);
        });

        const formattedObject = {
          'color'    : this.colorTransData,
          'data' : graphDataArray,
          'legend'    : this.graphLegend,
          'totalCount' : this.applicationValue.vulnerabilities,
          'legendTextcolor' : legendTextcolor,
          'link': true,
          'styling': {
            Â 'cursor': 'pointer'
          }
      };
        this.graphData = formattedObject;
       }

  }

  /**
   * This function navigates the page mentioned in the routeTo variable with a querypareams
   */

  navigatePage(event) {
    try {
      this.workflowService.addRouterSnapshotToLevel(this.router.routerState.snapshot.root);
      const eachParams = {};
      const newParams = this.utils.makeFilterObj(eachParams);
      if (this.routeTo !== undefined ) {
        this.router.navigate(['../', this.routeTo], {relativeTo: this.activatedRoute, queryParams: newParams , queryParamsHandling: 'merge'});
      }
    } catch (error) {
      this.errorMessage = this.errorHandling.handleJavascriptError(error);
      this.logger.log('error', error);
    }
  }
  navigateDataTable(event) {
    try {
      this.workflowService.addRouterSnapshotToLevel(this.router.routerState.snapshot.root);
      let queryObj = event;
      queryObj = queryObj.charAt(1);
      const eachParams = { 'severitylevel' : queryObj };
      const newParams = this.utils.makeFilterObj(eachParams);

      if ( (queryObj !== undefined) && (this.routeTo !== undefined) ) {
        this.router.navigate(['../', this.routeTo], {relativeTo: this.activatedRoute, queryParams: newParams, queryParamsHandling: 'merge'});
      }
    } catch (error) {
      this.errorMessage = this.errorHandling.handleJavascriptError(error);
      this.logger.log('error', error);
    }
  }
  /* navigatePage, navigateDataTable function ends here */
  ngOnDestroy() {
    try {
      this.subscriptionToAssetGroup.unsubscribe();
      clearInterval(this.autorefreshInterval);
    } catch (error) {

    }
  }

}
